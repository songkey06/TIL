2025년 08월 06일

오늘의 한일
1. 시나리오 작성
2. 디렉터리 구조 정하기
3. DB구조 정하기

시나리오
### 시나리오 1: 소설가 지망생 '김작가'의 첫 작품 등록 및 릴레이 시작

**등장인물**: 김작가 (닉네임: 별숲의몽상가)

**목표**: 자신의 아이디어를 바탕으로 소설을 시작하고, 다른 사람들의 참여를 유도하여 릴레이를 활성화시킨다.

---

1.  **[회원가입 및 로그인]**
    *   **사용자 행동**: 김작가가 Vibe Fiction에 접속하여 아이디, 닉네임('별숲의몽상가') 등을 입력하고 회원가입을 완료한다.
    *   **💻 데이터베이스 동작**:
        *   `USERS` 테이블에 새로운 행(Row)이 추가됩니다.
        *   **`INSERT INTO USERS (login_id, password, nickname, ...)`**
        *   `user_id`로 `1번`이 자동 부여됩니다. (예시)

2.  **[새 소설 생성 - AI 보조 창작 모드]**
    *   **사용자 행동**: 김작가가 '새 소설 쓰기' 버튼을 누르고, 소설 제목("사라진 도시, 아틀란티스의 마지막 기록"), 장르("판타지", "미스터리"), 시놉시스 등을 입력한다. AI의 도움을 받아 1화 원고를 완성한다.
    *   **💻 데이터베이스 동작**: 이 단계에서는 아직 아무것도 저장되지 않습니다. 모든 정보는 웹 페이지에 임시로 존재합니다.

3.  **[1화 등록 및 릴레이 설정]**
    *   **사용자 행동**: 김작가가 '등록' 버튼을 클릭한다.
    *   **💻 데이터베이스 동작 (가장 중요!)**:
        *   **1단계: 소설 정보 저장**
            *   `NOVELS` 테이블에 새로운 행이 추가됩니다.
            *   **`INSERT INTO NOVELS (title, synopsis, author_id, ...)`**
            *   `title`: "사라진 도시, 아틀란티스의 마지막 기록"
            *   `author_id`: `1` (김작가의 user_id)
            *   이때, `novel_id`로 `101번`이 자동 부여됩니다. (예시)
        *   **2단계: 장르 정보 연결**
            *   `NOVEL_GENRES` 테이블에 두 개의 행이 추가됩니다.
            *   **`INSERT INTO NOVEL_GENRES (novel_id, genre_id)`**
            *   `VALUES (101, 5)`  (*장르 5번이 '판타지'라고 가정*)
            *   `VALUES (101, 8)`  (*장르 8번이 '미스터리'라고 가정*)
        *   **3단계: 1화 정보 저장**
            *   `CHAPTERS` 테이블에 새로운 행이 추가됩니다.
            *   **`INSERT INTO CHAPTERS (novel_id, author_id, chapter_number, title, content, ...)`**
            *   `novel_id`: `101` (방금 생성된 소설 ID)
            *   `author_id`: `1` (1화는 원작자인 김작가가 작성)
            *   `chapter_number`: `1`
            *   `title`: "심해의 부름" (예시)
            *   `content`: 김작가가 작성한 1화 본문 내용
            *   이때, `chapter_id`로 `501번`이 자동 부여됩니다. (예시)

4.  **[초기 반응 확인 및 기대감]**
    *   **사용자 행동**: 다른 사용자가 김작가의 소설을 읽고 '좋아요'를 누른다.
    *   **💻 데이터베이스 동작**:
        *   `FAVORITES` 테이블에 새로운 행이 추가됩니다.
        *   **`INSERT INTO FAVORITES (user_id, target_type, target_id, category)`**
        *   `user_id`: 좋아요를 누른 사용자 ID (e.g., `2번`)
        *   `target_type`: `'NOVEL'`
        *   `target_id`: `101` (김작가의 소설 ID)
        *   `category`: `'LIKE'`

---

### 시나리오 2: 평범한 독자 '박독자'의 릴레이 참여 및 기여

**등장인물**: 박독자 (ID: `3번`, 닉네임: 책읽는고래)

**목표**: 흥미로운 소설을 발견하고, 투표와 제안을 통해 소설의 방향에 직접 영향을 미치며 '참여하는 독자'가 된다.

---

1.  **[소설 발견 및 탐색]**
    *   **사용자 행동**: 박독자가 '인기순' 정렬을 통해 김작가의 소설("사라진 도시...")을 발견하고 클릭한다.
    *   **💻 데이터베이스 동작**:
        *   서버는 `NOVELS` 테이블을 `view_count`나 `(좋아요 수)` 기준으로 `ORDER BY`하여 목록을 조회합니다.
        *   박독자가 소설을 클릭하면, 서버는 `NOVELS` 테이블의 `view_count`를 1 증가시킵니다.
        *   **`UPDATE NOVELS SET view_count = view_count + 1 WHERE novel_id = 101`**
        *   `CHAPTERS` 테이블에서 `WHERE novel_id = 101` 조건으로 모든 회차를 조회하여 페이지에 표시합니다.

2.  **[투표 참여]**
    *   **사용자 행동**: 박독자가 5화(예: `chapter_id=505`) 다음에 이어질 여러 제안 중 마음에 드는 제안 B(예: `proposal_id=702`)에 '투표하기' 버튼을 누른다.
    *   **💻 데이터베이스 동작**:
        *   **1단계: 투표 기록 저장**
            *   `VOTES` 테이블에 새로운 행이 추가됩니다.
            *   **`INSERT INTO VOTES (user_id, proposal_id)`**
            *   `user_id`: `3` (박독자의 ID)
            *   `proposal_id`: `702` (제안 B의 ID)
            *   *만약 박독자가 이미 이 제안에 투표했다면, DB의 복합 기본 키 제약조건 때문에 이 INSERT는 실패하고, 중복 투표가 막힙니다.*
        *   **2단계: 제안 득표 수 업데이트**
            *   `PROPOSALS` 테이블에서 해당 제안의 `vote_count`를 1 증가시킵니다.
            *   **`UPDATE PROPOSALS SET vote_count = vote_count + 1 WHERE proposal_id = 702`**

3.  **[이어쓰기 제안 작성]**
    *   **사용자 행동**: 박독자가 자신만의 아이디어로 다음 화 제안 D를 작성하여 제출한다.
    *   **💻 데이터베이스 동작**:
        *   `PROPOSALS` 테이블에 새로운 행이 추가됩니다.
        *   **`INSERT INTO PROPOSALS (chapter_id, proposer_id, content, vote_deadline, ...)`**
        *   `chapter_id`: `505` (5화 다음에 이어질 이야기)
        *   `proposer_id`: `3` (박독자의 ID)
        *   `content`: 박독자가 작성한 제안 내용
        *   `vote_deadline`: 지금부터 3일 뒤의 시각
        *   이때, `proposal_id`로 `704번`이 자동 부여됩니다. (예시)

4.  **[채택 결과 확인 (서버의 자동화된 작업)]**
    *   **서버 행동**: 투표 마감 시간이 지나고, 서버의 스케줄러가 자동으로 동작한다. 제안 B(`proposal_id=702`)가 최다 득표로 선정되었다고 가정한다.
    *   **💻 데이터베이스 동작**:
        *   **1단계: 제안 상태 변경**
            *   `PROPOSALS` 테이블에서 제안 B의 상태를 '채택됨'으로 변경합니다.
            *   **`UPDATE PROPOSALS SET status = 'ADOPTED' WHERE proposal_id = 702`**
        *   **2단계: 새로운 공식 회차 생성**
            *   `CHAPTERS` 테이블에 새로운 행이 추가됩니다.
            *   **`INSERT INTO CHAPTERS (novel_id, author_id, chapter_number, title, content, ...)`**
            *   `novel_id`: `101` (김작가의 소설 ID)
            *   `author_id`: 제안 B를 작성한 사용자의 ID (e.g., `4번`)
            *   `chapter_number`: `6`
            *   `content`: 제안 B의 본문 내용
        *   **3단계: 소설 정보 업데이트**
            *   `NOVELS` 테이블의 마지막 업데이트 시간을 현재 시간으로 갱신합니다.
            *   **`UPDATE NOVELS SET last_updated_at = NOW() WHERE novel_id = 101`**

이처럼 각 사용자 행동이 데이터베이스의 어떤 테이블에, 어떤 데이터로 기록되는지를 함께 설명하면, 프로젝트의 전체적인 데이터 흐름을 훨씬 더 명확하게 이해할 수 있습니다.

디렉토리 구조
### Vibe Fiction - 통합 디렉토리 구조 (Spring Boot + Thymeleaf)

```
vibe-fiction/
├── .gitignore
├── build.gradle              # 또는 pom.xml (Maven 사용 시)
├── README.md
└── src
    └── main
        ├── java
        │   └── com
        │       └── ai_dea
        │           └── vibefiction
        │               ├── VibeFictionApplication.java   # 메인 애플리케이션
        │               │
        │               ├── config/                   #  설정 관련 클래스
        │               │   ├── SecurityConfig.java     # Spring Security (로그인, 권한 관리)
        │               │   ├── WebConfig.java          # CORS, 인터셉터 등 웹 설정
        │               │   └── JpaConfig.java          # JPA 관련 추가 설정 (선택)
        │               │
        │               ├── domain/                   # 도메인 (엔티티)
        │               │   ├── user/
        │               │   │   ├── User.java
        │               │   │   └── Role.java (Enum)
        │               │   ├── novel/
        │               │   │   ├── Novel.java
        │               │   │   ├── Chapter.java
        │               │   │   ├── Genre.java
        │               │   │   └── ...
        │               │   ├── proposal/
        │               │   │   ├── Proposal.java
        │               │   │   └── Vote.java
        │               │   └── ...
        │               │
        │               ├── dto/                      # 데이터 전송 객체
        │               │   ├── request/                # 클라이언트 -> 서버
        │               │   │   ├── UserSignUpRequest.java
        │               │   │   ├── NovelCreateRequest.java
        │               │   │   └── ProposalCreateRequest.java
        │               │   └── response/               # 서버 -> 클라이언트
        │               │       ├── UserProfileResponse.java
        │               │       ├── NovelDetailResponse.java
        │               │       └── ProposalResponse.java
        │               │
        │               ├── controller/               # 컨트롤러 (요청 처리)
        │               │   ├── page/                   # 페이지 라우팅 전용 컨트롤러
        │               │   │   ├── HomeController.java   # 메인 페이지 (/)
        │               │   │   ├── NovelPageController.java # 소설 관련 페이지 (/novels/**)
        │               │   │   ├── UserPageController.java  # 마이페이지 (/mypage)
        │               │   │   └── ...
        │               │   └── api/                    # REST API 전용 컨트롤러
        │               │       ├── AuthApiController.java  # 회원가입, 로그인 API
        │               │       ├── NovelApiController.java # 소설 CRUD API
        │               │       ├── ProposalApiController.java # 제안, 투표 API
        │               │       └── ...
        │               │
        │               ├── service/                  # 비즈니스 로직
        │               │   ├── UserService.java
        │               │   ├── NovelService.java
        │               │   ├── ProposalService.java
        │               │   ├── VoteService.java
        │               │   ├── AiAssistantService.java   # AI API 연동 서비스
        │               │   └── FileStorageService.java   # 이미지 업로드/관리 서비스
        │               │
        │               ├── repository/               # 데이터 접근 (JPA Repository)
        │               │   ├── UserRepository.java
        │               │   ├── NovelRepository.java
        │               │   └── ProposalRepository.java
        │               │
        │               └── global/                   # 전역 컴포넌트
        │                   ├── exception/            # 예외 처리
        │                   │   ├── GlobalExceptionHandler.java
        │                   │   └── ErrorCode.java
        │                   └── scheduler/            # 스케줄러
        │                       └── VoteScheduler.java  # 투표 마감 처리 스케줄러
        │
        └── resources
            ├── application.yml         # 또는 application.properties (메인 설정)
            ├── static/                 # 정적 리소스
            │   ├── css/
            │   │   ├── common.css        # 공통 스타일
            │   │   └── main.css          # 메인 페이지 전용 스타일
            │   ├── js/
            │   │   ├── api.js            # AJAX/Fetch API 호출 공통 스크립트
            │   │   └── modal.js          # 모달창 제어 스크립트
            │   └── images/
            │       └── default-cover.png # 기본 표지 이미지
            │
            └── templates/              # Thymeleaf 템플릿
                ├── fragments/            # 공통 조각 (헤더, 푸터, 사이드바)
                │   ├── header.html
                │   └── footer.html
                ├── layout/               # 페이지 레이아웃
                │   └── default_layout.html # 기본 레이아웃
                │
                ├── index.html            # 1. 메인 페이지
                │
                ├── novel/
                │   ├── list.html           # 2. 소설 리스트 페이지 (소설 상세)
                │   ├── write.html          # 4. 글쓰기 페이지
                │   └──fragments/          # 소설 페이지 내에서만 쓰는 조각들
                │      └── proposal_list.html # 3. 다음화 창작/투표 영역
                │
                └── user/
                    ├── mypage.html         # 5. 마이페이지
                    └──fragments/
                       └── login_modal.html  # 로그인 모달
```

---

### 디렉토리 구조 설명

*   **`src/main/java` (백엔드)**
    *   **`config`**: Spring Security, Web MVC 등 프로젝트의 전반적인 설정을 관리합니다. 보안 로직과 일반 웹 설정을 분리하여 관리합니다.
    *   **`domain`**: 데이터베이스 테이블과 1:1로 매핑되는 **JPA 엔티티(@Entity)** 클래스들을 모아둡니다. 기능별로 하위 패키지(user, novel 등)를 두어 관리합니다.
    *   **`dto`**: 계층 간 데이터 전송을 위한 객체입니다. **Request(요청)**와 **Response(응답)**로 나누어 역할과 데이터 흐름을 명확하게 합니다.
    *   **`controller`**: 클라이언트의 요청을 받는 진입점입니다.
        *   **`page` 패키지**: Thymeleaf 뷰(HTML 페이지)를 반환하는 역할만 담당합니다. (e.g., `return "novel/list";`)
        *   **`api` 패키지**: JSON 형태의 데이터만 주고받는 **REST API**를 담당합니다. (e.g., `@RestController`, `@ResponseBody`) 페이지 로딩과 비동기 데이터 처리를 명확히 분리하여 유지보수성을 높입니다.
    *   **`service`**: 실제 비즈니스 로직이 처리되는 가장 중요한 부분입니다. 트랜잭션 관리(@Transactional)도 여기서 이루어집니다.
    *   **`repository`**: 데이터베이스에 접근하는 인터페이스(JPA Repository)들을 정의합니다.
    *   **`global`**: 예외 처리, 스케줄러 등 프로젝트 전반에 걸쳐 사용되는 공통 기능들을 배치합니다.

*   **`src/main/resources` (설정 및 프론트엔드 리소스)**
    *   **`static`**: CSS, JavaScript, 이미지 등 **정적 파일**을 위치시킵니다. Spring Boot가 자동으로 이곳의 파일들을 웹에서 접근할 수 있도록 해줍니다.
    *   **`templates`**: **Thymeleaf 템플릿 파일(HTML)**을 위치시킵니다.
        *   **`fragments`**: 모든 페이지에서 공통으로 사용되는 헤더, 푸터 등을 만들어 재사용성을 높입니다.
        *   **`layout`**: 전체 페이지의 뼈대가 되는 레이아웃을 정의합니다.
        *   기능별로 폴더(novel, user)를 나누어 관련된 HTML 파일들을 관리하면 구조가 깔끔해집니다.

이 구조는 **역할과 책임의 분리(SoC, Separation of Concerns)** 원칙을 따르기 때문에, 팀원들이 각자 맡은 부분에 집중하여 개발하기에 매우 효율적입니다.

DB구조
Vibe Fiction 데이터베이스 설계 및 시스템 아키텍처
1. 데이터베이스 설계 (ERD)
1.1 핵심 테이블 구조
sql-- 사용자 테이블
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    nickname VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    birth_date DATE NOT NULL,
    profile_image_url VARCHAR(500),
    is_adult BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- 소설 테이블
CREATE TABLE novels (
    novel_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    synopsis TEXT,
    cover_image_url VARCHAR(500),
    genre VARCHAR(50) NOT NULL,
    author_id BIGINT NOT NULL,
    visibility ENUM('PUBLIC', 'PRIVATE', 'FRIENDS') DEFAULT 'PUBLIC',
    is_relay BOOLEAN DEFAULT TRUE,
    is_adult_content BOOLEAN DEFAULT FALSE,
    max_word_count INT DEFAULT 1000,
    vote_duration_days INT DEFAULT 3,
    vote_ratio DECIMAL(3,2) DEFAULT 1.00,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status ENUM('ACTIVE', 'INACTIVE', 'COMPLETED') DEFAULT 'ACTIVE',
    FOREIGN KEY (author_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- 회차 테이블
CREATE TABLE episodes (
    episode_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    novel_id BIGINT NOT NULL,
    episode_number INT NOT NULL,
    title VARCHAR(200),
    content TEXT NOT NULL,
    author_id BIGINT NOT NULL,
    word_count INT DEFAULT 0,
    is_official BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (novel_id) REFERENCES novels(novel_id) ON DELETE CASCADE,
    FOREIGN KEY (author_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY unique_episode (novel_id, episode_number)
);

-- 창작 댓글 (릴레이 제안) 테이블
CREATE TABLE creative_comments (
    comment_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    novel_id BIGINT NOT NULL,
    episode_number INT NOT NULL,
    author_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    word_count INT DEFAULT 0,
    vote_count INT DEFAULT 0,
    is_adopted BOOLEAN DEFAULT FALSE,
    voting_deadline TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (novel_id) REFERENCES novels(novel_id) ON DELETE CASCADE,
    FOREIGN KEY (author_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- 투표 테이블
CREATE TABLE votes (
    vote_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    comment_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (comment_id) REFERENCES creative_comments(comment_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY unique_vote (comment_id, user_id)
);

-- 감상 댓글 테이블
CREATE TABLE review_comments (
    review_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    novel_id BIGINT NOT NULL,
    episode_id BIGINT,
    user_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    rating TINYINT CHECK (rating >= 1 AND rating <= 5),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (novel_id) REFERENCES novels(novel_id) ON DELETE CASCADE,
    FOREIGN KEY (episode_id) REFERENCES episodes(episode_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- 좋아요 테이블
CREATE TABLE likes (
    like_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    novel_id BIGINT,
    episode_id BIGINT,
    user_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (novel_id) REFERENCES novels(novel_id) ON DELETE CASCADE,
    FOREIGN KEY (episode_id) REFERENCES episodes(episode_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY unique_novel_like (novel_id, user_id),
    UNIQUE KEY unique_episode_like (episode_id, user_id)
);

-- 즐겨찾기 테이블
CREATE TABLE bookmarks (
    bookmark_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    novel_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (novel_id) REFERENCES novels(novel_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY unique_bookmark (novel_id, user_id)
);

-- 친구 관계 테이블 (Should Have)
CREATE TABLE friendships (
    friendship_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    requester_id BIGINT NOT NULL,
    addressee_id BIGINT NOT NULL,
    status ENUM('PENDING', 'ACCEPTED', 'BLOCKED') DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (requester_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (addressee_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY unique_friendship (requester_id, addressee_id)
);

-- 알림 테이블 (Should Have)
CREATE TABLE notifications (
    notification_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    type ENUM('LIKE', 'COMMENT', 'VOTE', 'ADOPTION', 'FRIEND_REQUEST') NOT NULL,
    related_id BIGINT,
    message VARCHAR(500) NOT NULL,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- 신고 테이블 (Should Have)
CREATE TABLE reports (
    report_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    reporter_id BIGINT NOT NULL,
    reported_user_id BIGINT,
    reported_novel_id BIGINT,
    reported_comment_id BIGINT,
    reason ENUM('SPAM', 'INAPPROPRIATE', 'COPYRIGHT', 'OTHER') NOT NULL,
    description TEXT,
    status ENUM('PENDING', 'RESOLVED', 'REJECTED') DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (reporter_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (reported_user_id) REFERENCES users(user_id) ON DELETE SET NULL,
    FOREIGN KEY (reported_novel_id) REFERENCES novels(novel_id) ON DELETE SET NULL
);

-- 임시 저장 테이블 (Should Have)
CREATE TABLE drafts (
    draft_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    novel_id BIGINT,
    type ENUM('EPISODE', 'CREATIVE_COMMENT', 'NOVEL') NOT NULL,
    title VARCHAR(200),
    content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (novel_id) REFERENCES novels(novel_id) ON DELETE CASCADE
);
1.2 확장성을 위한 추가 테이블 (Could Have/Won't Have 대비)
sql-- 태그 시스템 (Could Have)
CREATE TABLE tags (
    tag_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE novel_tags (
    novel_id BIGINT NOT NULL,
    tag_id BIGINT NOT NULL,
    PRIMARY KEY (novel_id, tag_id),
    FOREIGN KEY (novel_id) REFERENCES novels(novel_id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(tag_id) ON DELETE CASCADE
);

-- 사용자 등급 시스템 (Could Have)
CREATE TABLE user_achievements (
    achievement_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    type ENUM('AUTHOR', 'CONTRIBUTOR', 'READER') NOT NULL,
    level INT DEFAULT 1,
    experience_points INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);
2. Spring Boot 디렉토리 구조
src/
├── main/
│   ├── java/
│   │   └── com/
│   │       └── vibefiction/
│   │           └── relay/
│   │               ├── VibeFictionApplication.java
│   │               ├── config/
│   │               │   ├── SecurityConfig.java
│   │               │   ├── WebConfig.java
│   │               │   └── DatabaseConfig.java
│   │               ├── controller/
│   │               │   ├── HomeController.java
│   │               │   ├── UserController.java
│   │               │   ├── NovelController.java
│   │               │   ├── EpisodeController.java
│   │               │   ├── CommentController.java
│   │               │   └── ApiController.java
│   │               ├── service/
│   │               │   ├── UserService.java
│   │               │   ├── NovelService.java
│   │               │   ├── EpisodeService.java
│   │               │   ├── CommentService.java
│   │               │   ├── VoteService.java
│   │               │   ├── NotificationService.java
│   │               │   └── AIService.java
│   │               ├── repository/
│   │               │   ├── UserRepository.java
│   │               │   ├── NovelRepository.java
│   │               │   ├── EpisodeRepository.java
│   │               │   ├── CreativeCommentRepository.java
│   │               │   ├── VoteRepository.java
│   │               │   ├── ReviewCommentRepository.java
│   │               │   ├── LikeRepository.java
│   │               │   └── BookmarkRepository.java
│   │               ├── entity/
│   │               │   ├── User.java
│   │               │   ├── Novel.java
│   │               │   ├── Episode.java
│   │               │   ├── CreativeComment.java
│   │               │   ├── Vote.java
│   │               │   ├── ReviewComment.java
│   │               │   ├── Like.java
│   │               │   ├── Bookmark.java
│   │               │   ├── Notification.java
│   │               │   └── Draft.java
│   │               ├── dto/
│   │               │   ├── request/
│   │               │   │   ├── UserRegistrationRequest.java
│   │               │   │   ├── NovelCreateRequest.java
│   │               │   │   ├── EpisodeCreateRequest.java
│   │               │   │   └── CommentCreateRequest.java
│   │               │   └── response/
│   │               │       ├── NovelListResponse.java
│   │               │       ├── NovelDetailResponse.java
│   │               │       ├── EpisodeResponse.java
│   │               │       └── CommentResponse.java
│   │               ├── exception/
│   │               │   ├── GlobalExceptionHandler.java
│   │               │   ├── BusinessException.java
│   │               │   └── ErrorCode.java
│   │               └── util/
│   │                   ├── SecurityUtil.java
│   │                   ├── FileUtil.java
│   │                   └── ValidationUtil.java
│   └── resources/
│       ├── static/
│       │   ├── css/
│       │   ├── js/
│       │   └── images/
│       ├── templates/
│       │   ├── index.html
│       │   ├── novel/
│       │   │   ├── list.html
│       │   │   ├── detail.html
│       │   │   └── create.html
│       │   ├── episode/
│       │   │   ├── create.html
│       │   │   └── vote.html
│       │   ├── user/
│       │   │   ├── login.html
│       │   │   ├── register.html
│       │   │   └── mypage.html
│       │   └── fragments/
│       │       ├── header.html
│       │       ├── footer.html
│       │       └── modal.html
│       ├── application.yml
│       └── data.sql
3. 시스템 아키텍처 흐름도
3.1 전체 시스템 아키텍처
[Client Browser]
       ↕ HTTP/HTTPS
[Load Balancer] (Optional)
       ↕
[Spring Boot Application]
├── Controller Layer (MVC)
├── Service Layer (Business Logic)
├── Repository Layer (Data Access)
└── Security Layer (Authentication/Authorization)
       ↕
[MariaDB Database]
       ↕
[AI Service API] (ChatGPT/Claude 등)
3.2 핵심 기능 플로우
릴레이 소설 생성 및 연재 플로우
1. 사용자 로그인 → 2. 새 소설 생성 → 3. 1화 작성 (AI 보조 가능)
                    ↓
4. 소설 공개 설정 → 5. 다른 사용자들이 창작 댓글 작성
                    ↓
6. 투표 기간 동안 투표 → 7. 최다 득표 댓글 채택 → 8. 공식 다음 화로 등록
                    ↓
9. 알림 발송 → 10. 반복 (다음 화 창작 댓글 모집)
투표 시스템 플로우
[창작 댓글 작성] → [투표 기간 시작 (3일)] → [사용자들 투표]
                                        ↓
[투표 마감] → [득표수 계산] → [최다 득표 댓글 선정]
                            ↓
[동점 시 원작자 선택] → [공식 다음 화 등록] → [알림 발송]

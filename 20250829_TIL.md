2025년 08월 29일

오늘 배운것
리엑트 JS 1,2

### React.js 개요 및 주요 특징

React.js는 Facebook이 개발한 UI(사용자 인터페이스) 라이브러리로, 복잡한 UI를 효율적으로 관리하기 위해 등장했습니다. 기존의 자바스크립트(Vanilla JS)가 복잡한 UI를 다루기 어려웠던 점을 개선하기 위해 다음과 같은 이점을 제공합니다.

* **컴포넌트 기반 아키텍처:** UI를 독립적이고 재사용 가능한 부품(컴포넌트)으로 나누어 개발합니다. 이를 통해 코드의 재사용성을 높이고 유지보수를 쉽게 만듭니다.
* **Virtual DOM:** 데이터가 변경될 때마다 전체 UI를 새로 그리는 대신, 변경된 부분만 업데이트하여 렌더링 성능을 향상시킵니다.
* **선언적 접근 방식:** 개발자가 UI가 '어떤 모습'이어야 하는지를 선언하면, React가 '어떻게' 업데이트할지 알아서 처리합니다.

---

### React 컴포넌트

React의 핵심 개념인 **컴포넌트**는 재사용 가능한 코드 묶음으로, 독립적인 기능을 수행합니다. 컴포넌트는 주로 두 가지 종류로 나뉩니다.

* **함수 컴포넌트:** 가장 간단한 형태로, `props` 객체를 매개변수로 받아 React 요소를 반환하는 자바스크립트 함수입니다.
* **클래스 컴포넌트:** ES6 클래스를 사용하며, `state` 관리나 생명주기 메서드 같은 추가 기능을 제공합니다.

컴포넌트는 `props`와 `state`라는 두 가지 데이터를 사용합니다. `props`는 부모로부터 전달받는 읽기 전용 데이터이고, `state`는 컴포넌트 내부에서 변경 가능한 데이터입니다.

---

### React 컴포넌트의 장점

* **재사용성:** 한 번 만든 컴포넌트는 여러 곳에서 재사용할 수 있습니다.
* **분리 및 모듈화:** 각 컴포넌트가 독립적이어서 코드가 분리되고 체계적으로 관리됩니다.
* **효율적인 관리:** 복잡한 UI를 작은 부분으로 나누어 개발하고 유지보수하기 용이합니다.

### 리액트와 JSX의 관계

리액트는 사용자 인터페이스를 만드는 자바스크립트 라이브러리이고, **JSX(JavaScript XML)**는 리액트에서 HTML과 비슷하게 UI를 표현할 수 있도록 도와주는 자바스크립트 확장 문법입니다.
 JSX 코드는 실제로는 브라우저가 이해할 수 있는 자바스크립트(`React.createElement()`)로 변환되어 실행됩니다. 

---

### 선언적 프로그래밍 vs. 명령적 프로그래밍

프로그래밍 방식에는 **선언적**과 **명령적** 두 가지가 있습니다.

* **선언적 프로그래밍:** '무엇을 할 것인가'에 집중하며, 목표를 선언하는 방식입니다. 리액트가 이 방식을 따르기 때문에 코드가 더 읽기 쉽고 디버깅이 편해집니다.
* **명령적 프로그래밍:** '어떻게 할 것인가'에 집중하며, 모든 과정을 명시적으로 작성하는 방식입니다.

---

### JSX 태그 작성 규칙

JSX를 작성할 때는 몇 가지 규칙을 지켜야 합니다.

* **하나의 루트 태그:** 컴포넌트는 반드시 하나의 태그로 감싸져야 합니다.
* **자기 닫힘 태그:** HTML에서 닫는 태그가 없는 `<img src="" >`와 같은 태그도 JSX에서는 `<img src="" />`처럼 반드시 닫아야 합니다.
* **React Fragment:** 불필요한 `<div>` 태그를 추가하지 않고 여러 요소를 그룹화할 때 사용합니다. `React.Fragment`나 단축 문법인 `<>`를 사용해 DOM에 불필요한 노드가 추가되는 것을 막을 수 있습니다.

---

### React Props의 개념과 사용법
React의 **Props(속성)**는 부모 컴포넌트가 자식 컴포넌트에게 데이터를 전달하는 방법입니다.  이 방식은 데이터가 한 방향(부모 → 자식)으로만 흐르는 React의 특징을 따르며, 컴포넌트를 재사용 가능하게 만듭니다.
 Props는 문자열, 숫자, 불리언, 배열, 객체, 함수 등 다양한 형태의 자바스크립트 데이터를 전달할 수 있습니다.

### props.children
**props.children**은 컴포넌트의 여는 태그와 닫는 태그 사이에 있는 내용을 담고 있는 특별한 속성입니다. 이 기능을 사용하면 <div>와 같은 불필요한 HTML 요소로 감싸지 않고도 여러 요소를 전달할 수 있어,
 '포함(Wrapper)' 컴포넌트를 만들 때 유용합니다. props.children을 활용하면 컴포넌트의 내부 콘텐츠를 동적으로 구성할 수 있습니다.

---

### 이벤트 바인딩이란?

이벤트 바인딩은 특정 이벤트(예: 버튼 클릭)가 발생했을 때 미리 정의된 함수(이벤트 핸들러)를 실행하도록 연결하는 과정입니다.

  * **바닐라 자바스크립트:** `addEventListener` 메서드를 사용해 HTML 요소에 직접 이벤트를 연결합니다.
  * **React:** JSX 문법을 사용하여 이벤트 핸들러를 JSX 요소에 연결합니다. 핸들러 이름은 `onClick`처럼 \*\*카멜케이스(camelCase)\*\*로 작성하며, 함수를 값으로 전달합니다.

-----

### React 이벤트 바인딩 방식의 특징

React는 가상 DOM을 사용하기 때문에 이벤트 핸들러가 컴포넌트 내부에 정의될 때 더 효율적으로 작동합니다. 컴포넌트가 리렌더링 될 때마다 새로운 함수를 참조하는 것을 방지해 성능을 개선할 수 있습니다.

#### 1\. 외부에 선언 후 바인딩

```javascript
function handleClick() {
    console.log('클릭!');
}

function MyButton() {
    return <button onClick={handleClick}>클릭하세요!</button>;
}
```

  * **장점:** 함수가 한 번만 생성되어 여러 컴포넌트에서 재사용 가능합니다.
  * **단점:** 컴포넌트의 `props`나 `state`에 접근할 수 없습니다.

#### 2\. 인라인 바인딩 (화살표 함수 사용)

```javascript
function MyButton() {
    return (
        <button onClick={() => console.log('클릭!')}>
            클릭하세요!
        </button>
    );
}
```

  * **장점:** `props`나 `state`에 쉽게 접근할 수 있습니다.
  * **단점:** 컴포넌트가 렌더링될 때마다 함수가 새로 생성되어 성능에 영향을 줄 수 있습니다.

결론적으로, `props`나 `state`를 사용하지 않는 간단한 이벤트 핸들러는 외부에 선언하는 것이 좋고, 컴포넌트의 상태에 접근해야 하는 경우는 인라인 방식을 사용하는 것이 편리합니다.

---

### React State (상태)란?

React에서 \*\*상태(state)\*\*는 컴포넌트 내부에서 관리되는 데이터로, 시간이 지남에 따라 변할 수 있는 값입니다. 사용자의 입력이나 API 응답에 따라 상태가 바뀌면, React는 해당 컴포넌트를 다시 렌더링하여 변경된 내용을 화면에 보여줍니다.

-----

### 상태 관리의 핵심: `useState` 훅

함수형 컴포넌트에서 상태를 관리하기 위해 **`useState`** 훅을 사용합니다. `useState`를 호출하면 두 가지 요소를 가진 배열이 반환됩니다.

1.  **상태 변수:** 현재 상태 값을 담고 있는 변수입니다.
2.  **상태 변경 함수(Setter):** 이 함수를 통해서만 상태 값을 변경해야 합니다.

<!-- end list -->

```javascript
const [myState, setMyState] = useState(initialValue);
```

**상태값을 직접 수정하지 않고 Setter 함수를 사용해야 하는 이유**는 React가 이 함수를 통해 상태 변경을 감지하고, 컴포넌트를 최적화된 방식으로 다시 렌더링하기 때문입니다.
 상태의 \*\*불변성(immutability)\*\*을 유지하는 것은 React 앱의 성능과 안정성을 위해 매우 중요합니다.

-----

### `useState`를 활용한 예제

버튼을 클릭할 때마다 클릭 횟수를 보여주는 간단한 예시를 통해 `useState`의 작동 방식을 이해할 수 있습니다.  버튼을 클릭하면 `handleClick` 함수가 `setCount`를 호출하여 상태 변수인 `count` 값을 1씩 증가시킵니다.
 `setCount`가 호출될 때마다 React는 `ClickCounter` 컴포넌트를 재렌더링하여 화면의 숫자를 업데이트합니다.

---

### React 상태 관리 방법: 단일 값 vs 객체

React에서 상태를 관리하는 방법은 크게 두 가지가 있습니다.

  * **단일 값 상태:** `const [enteredTitle, setEnteredTitle] = useState('');` 와 같이 각 상태를 독립적으로 관리하는 방식입니다.
  * **객체 상태:** `const [userInput, setUserInput] = useState({ enteredTitle: '' });` 와 같이 여러 상태를 하나의 객체로 묶어 관리하는 방식입니다.

어떤 방식을 선택할지는 개인의 선호도나 프로젝트 상황에 따라 다를 수 있습니다.

-----

### 상태 업데이트와 불변성

React에서 상태를 업데이트할 때는 **불변성**을 지키는 것이 매우 중요합니다. 이는 특히 객체나 배열처럼 여러 요소를 담고 있는 상태를 다룰 때 더욱 중요해집니다.
 상태를 직접 수정하는 대신, \*\*스프레드 연산자(...)\*\*를 사용하여 기존 객체의 내용을 복사하고, 필요한 부분만 새로운 값으로 덮어쓰는 방식으로 새로운 객체를 만들어야 합니다.

```javascript
// 올바른 상태 업데이트
setUserInput({
  ...userInput,
  enteredTitle: e.target.value
});
```

-----

### 비동기적 상태 업데이트

React의 상태 업데이트는 **비동기적으로** 처리됩니다. 이는 여러 상태 업데이트 요청이 연달아 발생할 때, 이전 상태가 아직 반영되지 않은 상태에서 다음 업데이트가 진행될 수 있다는 것을 의미합니다.
 이 문제를 해결하기 위해, `useState`의 Setter 함수에 **콜백 함수**를 전달하는 방법을 사용합니다.

```javascript
// 비동기적 상태 업데이트 문제 해결
setUserInput((prevUserInput) => ({
  ...prevUserInput,
  enteredTitle: e.target.value
}));
```

이렇게 하면 React는 항상 최신 상태를 사용하여 업데이트를 진행하므로, 여러 업데이트가 서로 충돌하는 것을 방지할 수 있습니다.

---

### 상향식 데이터 전달(Lifting State Up)의 개념
리액트에서는 데이터가 단방향으로, 즉 부모 컴포넌트에서 자식 컴포넌트로만 흐릅니다.  그렇기 때문에 자식 컴포넌트가 부모 컴포넌트의 상태를 직접 바꿀 수 없습니다.

상향식 데이터 전달은 이 문제를 해결하는 중요한 패턴입니다. 부모 컴포넌트가 상태를 변경하는 함수를 props로 자식에게 전달하고, 자식은 이벤트가 발생했을 때 이 함수를 호출하여 부모에게 상태 변경을 요청합니다.

# 예시 코드 분석
아래 코드에서 NewExpense는 ExpenseForm의 부모 컴포넌트입니다.

import React from 'react';

// 자식 컴포넌트: 사용자의 입력을 처리하고 부모에게 전달하는 역할
const ExpenseForm = ({ onSaveExpense }) => {
  // ... (상태 관리 로직)

  const submitHandler = (e) => {
    e.preventDefault();

    const expense = {
      // ... (사용자 입력 값)
    };

    // 부모로부터 받은 함수를 호출하여 데이터 전달
    onSaveExpense(expense);
  };
  
  // ... (폼 렌더링)
};

// 부모 컴포넌트: 자식으로부터 받은 데이터를 처리하는 역할
const NewExpense = ({ onAddExpense }) => {

  const saveExpenseHandler = (expense) => {
    const newExpense = {
      ...expense,
      id: Math.floor(Math.random() * 99999)
    };

    // 최종적으로 부모의 부모 컴포넌트로 데이터 전달
    onAddExpense(newExpense);
  };

  return (
    <div className='new-expense'>
      {/* 함수를 props로 자식에게 전달 */}
      <ExpenseForm onSaveExpense={saveExpenseHandler} />
    </div>
  );
};

export default NewExpense;

NewExpense는 saveExpenseHandler라는 함수를 정의하고, 이 함수를 onSaveExpense라는 이름의 props로 ExpenseForm에 전달합니다.
 ExpenseForm에서는 폼 제출 이벤트가 발생하면 onSaveExpense(expense)를 호출하여 입력값을 NewExpense에 전달합니다.
 이렇게 하면 NewExpense는 받은 데이터를 처리하고, 다시 더 상위 컴포넌트로 데이터를 전달할 수 있게 됩니다.

이 패턴은 코드의 구조를 명확하게 하고, 상태 관리의 복잡성을 줄이는 데 큰 도움이 됩니다.

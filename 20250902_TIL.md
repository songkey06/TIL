체스 프로젝트
===


[디비 설계]
기물 디비: 자신의 행마법 기록
체스판 디비: 기물들의 위치 기록
로그 디비: 기물이 이동로그(즉 순서도 기억함) 기록
---------------
플레이어가 기물을 선택하면 '로그디비'에서 행마법을 로드하고 가능한 위치를 표시함
표시된 칸을 클릭하면 움직이고 '체스판디비'와 '로그디비'에 위치 업데이트
표시된 칸 이외에 클릭하면 기물 선택 취소
상대 기물과 겹치면 먼저 있던 '로그 디비'에 저장하고 '체스판 디비'에서 기물 삭제
----------
 {기물 디비}
기물 종류(PK) | 행마법 | 비고
예: pawn | 대각선으로 잡거나 앞전진 | null
---------------
{체스판 디비}
위치(PK) | 기물색 | 기물종류(FK)
예: e4 | white | pawn
--------------------
 {로그 디비}
수(PK) | 움직인 기물의 시작 위치 | 움직인 기물의 도착 위치 | 비고 | 수를 둔 플레이어의 색
예: 1 | e2 | e4 | null | white
=================


[api명세 정의]
-------------------
{api엔드포인트 설계}

-POST /api/chess/start: 게임 시작
-POST/api/chess/end: 게임 끝
-GET /api/chess/{gameId}: 게임 상태 조회
-POST /api/chess/{gameId}/move: 기물 이동
-----------------------
{요청(Request) 및 응답(Response) 형식 정의}: 
각 엔드포인트가 주고받을 데이터의 구조를 JSON 형태로 구체화합니다.

-기물 이동 요청: { "from": "e2", "to": "e4" }
-게임 상태 응답: { "board": { ... }, "turn": "white", "isCheck": false, ... }
=========


[백엔드 개발(스프링)]
API 명세에 따라 백엔드 로직을 구현합니다. 이 단계에서 데이터베이스와 연동하고 게임 규칙을 처리합니다.

{RESTful API 컨트롤러 구현}
-API 명세에 정의된 URL을 처리하는 컨트롤러(@RestController)를 작성합니다.

{서비스 레이어 구현}
-게임의 핵심 로직(기물 행마 규칙, 체크, 체크메이트 판단 등)을 처리하는 서비스 클래스를 개발합니다.

[데이터베이스 연동}
-JPA(Hibernate)나 MyBatis 같은 ORM/프레임워크를 사용해 앞서 설계한 데이터베이스와 연동합니다.

{Board 엔티티}
-체스판 상태를 관리합니다.

{Move 엔티티}
-로그 디비에 기록을 저장합니다.

[게임 로직 구현}
-move API: 요청된 수가 유효한지 검증하고, 유효하다면 체스판 디비와 로그 디비를 업데이트합니다.
-상태 관리: 현재 턴, 체크 상태, 게임 종료 여부 등을 관리합니다.

==========


[프론트 개발(리엑트)]
백엔드에서 구현한 API를 호출하여 사용자 인터페이스를 만듭니다.

{컴포넌트 설계}
-체스판, 기물, 게임 정보(턴, 로그) 등 UI 요소를 리액트 컴포넌트로 나눕니다.

{API 연동}
-fetch나 axios 라이브러리를 사용해 백엔드 API를 호출하고 데이터를 받아옵니다.

useEffect 훅을 사용해 게임 상태를 주기적으로 업데이트하거나, 기물 이동 후 API를 호출합니다.

{상태 관리}
-리액트의 useState나 Redux/Zustand 같은 상태 관리 라이브러리를 이용해 게임 상태를 프론트엔드에서 효율적으로 관리합니다.

{UI/UX 구현}
-기물 선택 시 가능한 위치를 표시하고, 클릭 이벤트에 따라 API를 호출하는 등 사용자 상호작용을 구현합니다.

1.pk와 fk 혼동
고객님이 혼동하고 있는 부분은 PK와 FK의 관계, 그리고 '로그 디비'의 역할에 대한 오해인 것 같습니다.

### **오해 1: FK(외래 키)는 무조건 가져야 한다?**

* **고객님의 생각**: '로그 디비'가 체스판과 관련된 정보를 기록하려면 '체스판 디비'의 FK를 가져야 한다고 생각하신 것 같습니다.
* **설명**: 모든 테이블이 반드시 FK를 가져야 하는 것은 아닙니다. FK는 다른 테이블의 PK를 참조하여 **테이블 간의 관계를 정의**하는 역할을 합니다. 하지만, **로그 디비**와 같이 특정 사건이나 이벤트를 기록하는 테이블은 그 자체로 의미를 가지며, 다른 테이블을 참조하지 않고도 유효한 정보를 담을 수 있습니다. 제가 제안한 설계에서 로그 디비는 '이동'이라는 사건 자체를 기록하므로, FK 없이도 충분합니다.

---

### **오해 2: FK는 데이터의 '흐름'을 표현하는 수단이다?**

* **고객님의 생각**: '체스판 디비'와 '로그 디비'를 연결하여 데이터의 '흐름'을 표현하고 싶어 하신 것 같습니다.
* **설명**: FK는 데이터의 흐름보다는 **데이터 간의 정적이고 구조적인 관계**를 나타내는 데 주로 사용됩니다. 예를 들어, **체스판 디비**의 '기물종류(FK)'는 **기물 디비**의 '기물 종류(PK)'를 참조하여 '이 체스판의 이 위치에는 어떤 종류의 기물이 있다'는 정적인 정보를 나타냅니다.
    * 반면, 로그 디비는 **시간에 따라 변하는 동적인 사건**을 기록합니다. 이러한 동적인 흐름은 FK로 표현하기보다는 '시작 위치'와 '도착 위치'와 같은 속성을 통해 표현하는 것이 더 적절합니다.

---

### **정리**

고객님께서 혼동하신 핵심은 **FK가 '정적 관계'를 정의하는 데 사용되는 것**과 **로그 디비가 '동적인 사건'을 기록하는 역할** 사이의 차이입니다.

**PK(기본 키)**는 각 테이블의 행을 고유하게 식별하는 '주민등록번호'와 같습니다. **FK(외래 키)**는 이 주민등록번호를 다른 테이블에 넣어 두 테이블을 '연결'하는 역할을 합니다.

로그 디비에 FK를 추가하여 체스판 디비의 특정 행을 참조하려고 하면, **게임이 진행될 때마다 기존의 로그를 계속 수정해야 하는 문제**가 발생합니다. 이는 매우 비효율적이고 복잡한 데이터 관리로 이어집니다. 제가 제안한 방식은 로그 디비가 '이동'이라는 사건을 기록하고, 필요할 때 이 기록을 바탕으로 체스판의 과거 상태를 재구성하는 방식으로, 데이터의 흐름을 효율적으로 관리할 수 있습니다.

======================


[트러블 슈팅]
2. API관련 혼동
### 1. API 엔드포인트와 JSON 데이터의 역할

* **API 엔드포인트**는 웹 서버의 특정 기능으로 연결되는 **주소**입니다. (예: `POST /api/chess/{gameId}/move`). 이는 '무엇을 할지'라는 행위를 정의합니다.
* **JSON 데이터**는 이 주소로 보낼 **내용물**입니다. `POST` 요청의 본문(body)에 담겨서 전송되며, '어떻게 할지'에 대한 구체적인 정보를 담고 있습니다. (예: `{ "from": "e2", "to": "e4" }`).
* 두 가지는 서로 다른 역할을 합니다. `POST`를 사용할 때는 **엔드포인트는 간결하게 유지**하고, **복잡한 데이터는 JSON에 담아 전송**하는 것이 표준적이고 효율적인 방법입니다.

---

### 2. HTTP 요청의 일시성과 데이터 관리

* **HTTP 요청은 일회성**입니다. 클라이언트가 `POST` 요청을 보내면, 서버는 그 요청을 한 번 처리하고 **데이터는 즉시 사라집니다.** 서버가 다음 요청을 위해 이전 JSON 데이터를 기억하고 있는 것이 아닙니다.
* **게임 상태는 데이터베이스에 저장됩니다.** 요청으로 받은 데이터는 서버의 메모리에 잠시 머물렀다가, 고객님이 설계한 **데이터베이스(DB)**에 기록됩니다.
* **DB가 게임의 상태를 영구적으로 기억**하는 역할을 합니다. 다음 요청이 오면, 서버는 이전에 보냈던 JSON을 기억하는 대신 DB에 저장된 최신 상태를 조회하여 처리합니다.
